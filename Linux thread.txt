===================================== 基础知识 ==========================================
程序：由数据和指令组成，是静态的，一般存在于磁盘中，当装载进内存后可被执行。
进程：是正在执行的程序， 是动态的，在计算机内存中， 包括程序的指令、数据以及程序运行需要的栈、堆、打开的文件等一切资源。

进程的状态：
	运行态、可中断睡眠态、不可中断睡眠态、停止态、僵尸态、死亡态。
进程的数据空间：
	常量区、静态区、堆区、栈区。
Linux采用虚拟内存机制来管理系统内存，每个进程的地址空间都是虚拟的，通过内存映射表对应物理内存。
段错误是操作系统的一种保护机制，当进程遇到了不可恢复的访存错误时，内核发出信号将该进程杀死。
段错误的原因：
	1. 地址非法。
	2. 权限非法。
查看进程状态的工具： 
	ps -ef
	ps aux
	pstree
	top
只有前台进程能够接受终端信号。
同一时刻只能有一组前台进程，但是可以有多组后台进程。
进程控制：
	fg	将后台进程变为前台
	bg	将暂停的进程便后后台执行。
	CTL + z	将前台进程暂停。
	CTL + c 将前台进程杀死。

进程标识：
	Linux使用一个short型的整数作为进程的ID， 范围是0 ~ 32767。
	
进程创建之后的执行顺序是随机的，也就意味着父进程在创建完子进程后谁先运行是不一定的。
僵尸进程：
	当一个进程终止后，系统为了能够让其父进程获得该进程的返回状态，
	于是会保留关于该进程的一些信息（例如返回状态等），但是此时进程的大部分资源都已经被收回了（指令、堆、栈、打开的文件等绝大部分资源）。
	此时的进程已经终止，但是未被完全销毁（依然占有PID、taskstruct 结构体等少量信息）称为僵尸进程。
僵尸进程的产生条件：
	1.父进程为终止并且没有主动忽略子进程的状态。
	2.子进程先于父进程终止。
僵尸进程的危害：
	1.占用PID资源
	2.占用内存资源。

==================================== 函数接口 ================================================
创建进程：
	pid_t fork(void);
	功能： 创建一个子进程。
	参数： 无。
	返回值：
		成功：在父进程空间返回子进程的PID，在子进程空间返回0； 失败： -1，没有子进程被创建。

结束进程：
	void exit(int status);
	功能： 结束当前进程。
	返回值：无，一旦调用永不返回。
	参数：	
		int status, 用户期望带回的状态值，一般表示任务是否成功。

	void _exit(int status) 同exit, 区别是_exit函数立即结束进程，不清理缓存。

获取进程状态/等待进程：
	pid_t wait（int *status）；
	功能：阻塞地等待一个进程结束，并获得其状态值。
	返回值： 成功，返回结束的子进程ID； 失败， -1；
	参数：
		int *status, 进程状态的接收缓冲区。

	waitpid(pid_t pid, int *status, int option);
	功能： 等待子进程结束，并获得状态值。
	返回值：失败，-1； 指定WNOHANG并且没有进程结束， 0； 成功， 结束的进程的ID。
	参数：
		1. pid_t pid, 指定等待的子进程。
		2. int *status, 进程状态的接收缓冲区。
		3. int option, 标志位选项，例如WNOHANG表示非阻塞方式获取子进程状态。

执行新程序：
	execlp
	execvp

	
守护进程（精灵进程）：
	通常是一个后台进程，它可以脱离终端的控制，不受终端影响，从而在后台执行特殊任务。
	
创建守护进程的步骤：
	1. 创建子进程，并且父进程结束。（保证新的子进程不是进程组组长，因为如果进程已经是某个进程组组长，将不能成功调用setsid）
	2. 子进程调用setsid(), 创建新的会话组并使自己成为新的会话组长。
	3. 关闭所有的文件描述符。（因为进程在创建过程中继承了来自于父进程的大量资源，为了保证新进程不受其影响，尽量释放这些不用的资源）
	4. 重设文件权限掩码。（为了保证新的守护进程可以不受限制地新建任何权限的文件）
	5. 更改工作路径到根。（当前进程占用工作路径会导致当前磁盘分区无法卸载）




最终权限 = 期望权限 & （~掩码）


======================================== 线程 ===========================================
UNIX/Linux的标准分类：
	BSD
	System V
	POSIX

pthread是遵循POSIX标准的thread。
线程是轻量级的进程。
进程是任务资源分配的基本单元。
线程是任务时间调度的基本单元。

回调函数


创建线程：
	int pthread_create(pthread_t *tid, pthread_attr_t *attru, void*(*callback)(void *), void *arg);
	功能： 创建一个线程，并让新的线程去实行callback函数。
	返回值： 成功， 0； 失败， 错误码。
	参数：
		1. pthread_t *tid, 用来存放新线程的标识。
		2. pthread_attr_t *attru, 线程的属性，一般不需要，置为NULL。
		3. void*(*callback)(void *), 回调函数，用来指示线程需要做什么。
		4. void *arg, 用来个回调函数传参数。

等待线程：
	int pthread_join(pthread_t tid, void **retval);
	功能： 等待一个线程结束，并获取其返回值。
	返回值： 成功， 0； 失败， 错误码。
	参数：
		1. pthread_t tid, 指定等待的线程标识。
		2. void **retval, 用来获得线程的返回值，如果不需要则置为NULL。

结束线程：
	void pthread_exit(void *retval);
	功能： 结束一个线程，并带回返回值。
	返回值：无，一旦调用则线程终止，无需返回。
	参数：
		void *retval, 将一个返回值带回给需要接受的线程。如果不需要则置为NULL。

取消线程：
	int pthread_cancel(pthread_t tid);
	功能： 取消一个线程。
	返回值： 成功， 0； 失败， 错误码。
	参数：
		pthread_t tid, 想要取消的线程标识。


互斥：
	保证在任务访问临界资源期间不被其他任务干扰，但是不能保证访问次序（同一个任务可能连续多次访问临界资源）。
	pthread_mutex_lock();
	pthread_mutex_unlock（);
同步：
	不仅要保证任务在访问临界资源期间不被干扰，并且好要保证任务间的访问次序。
	同步必定互斥。
	互斥未必同步。

	sem_init();
	sem_wait();
	sem_post();
	sem_destroy();



迪杰斯特拉算法
最短路径算法

semaphore
信号量
信号灯
POSIX信号量
POSIX信号灯


semaphore arrays
system V 信号灯
system V 信号量
信号灯集
信号量集


signal
信号


PV原语、PV操作：
P: 减少、下降、申请。
V: 增加、升起、释放。




作业：
	创建两个线程A、B, 主线程随机指定一个数值，然后AB两线程开始同步依次将该值减1，谁先减到0则胜出。
